define(['../Core/defaultValue',
        '../Core/defined',
        '../Core/DeveloperError',
        '../Core/WebMercatorTilingScheme',
        '../Core/GeographicTilingScheme',
        '../ThirdParty/when',
        '../Core/Event',
        '../Scene/TileReplacementQueue',
        '../Core/defineProperties',
        '../Core/Resource'],
    function (defaultValue,
              defined,
              DeveloperError,
              WebMercatorTilingScheme,
              GeographicTilingScheme,
              when,
              Event,
              TileReplacementQueue,
              defineProperties,
              Resource) {
        var MVTProvider = function (options) {
            options = defaultValue(options, defaultValue.EMPTY_OBJECT);

            this.owner = options.owner;
            this._tileWidth = defaultValue(options.tileWidth, 512);
            this._tileHeight = defaultValue(options.tileHeight, 512);
            this._readyPromise = when.resolve(true);

            this._key = defaultValue(options.key, "");
            if (!defined(options.url)) {
                throw new DeveloperError('mapbox vectortile service url is required.');
            }
            this._url = options.url;
            var mapExtent;
            if (options.projection.indexOf('3857') > -1) {
                this._tilingScheme = new WebMercatorTilingScheme();
                var sw = this._tilingScheme._rectangleSouthwestInMeters;
                var ne = this._tilingScheme._rectangleNortheastInMeters;
                mapExtent = [sw.x, sw.y, ne.x, ne.y];
            } else {
                this._tilingScheme = new GeographicTilingScheme();
                var rectangle = this._tilingScheme.rectangle;
                mapExtent = [rectangle.west, rectangle.south, rectangle.east, rectangle.north];
            }
            // this._resolutions = defaultValue(options.resolutions, ol.tilegrid.resolutionsFromExtent(mapExtent, 22, this._tileWidth));
            this._resolutions = options.resolutions;

            this._pixelRatio = 1;
            this._transform = [0.125, 0, 0, 0.125, 0, 0];
            this._replays = ["Default", "Image", "Polygon", "LineString", "Text", "Circle"];

            this._tileQueue = new TileReplacementQueue();
            this._cacheSize = defaultValue(options.cacheSize, 1000);


            this._errorEvent = new Event();
        }

        defineProperties(MVTProvider.prototype, {
            proxy: {
                get: function () {
                    return undefined;
                }
            },

            tileWidth: {
                get: function () {
                    return this._tileWidth;
                }
            },

            tileHeight: {
                get: function () {
                    return this._tileHeight;
                }
            },

            maximumLevel: {
                get: function () {
                    return undefined;
                }
            },

            minimumLevel: {
                get: function () {
                    return undefined;
                }
            },

            tilingScheme: {
                get: function () {
                    return this._tilingScheme;
                }
            },

            rectangle: {
                get: function () {
                    return this._tilingScheme.rectangle;
                }
            },

            tileDiscardPolicy: {
                get: function () {
                    return undefined;
                }
            },

            errorEvent: {
                get: function () {
                    return this._errorEvent;
                }
            },

            ready: {
                get: function () {
                    return true;
                }
            },

            readyPromise: {
                get: function () {
                    return this._readyPromise;
                }
            },

            credit: {
                get: function () {
                    return undefined;
                }
            },

            hasAlphaChannel: {
                get: function () {
                    return true;
                }
            },

            cacheSize: {
                get: function () {
                    return this._cacheSize;
                },
                set: function (value) {
                    if (this._cacheSize !== value) {
                        this._cacheSize = value;
                        // this.reload();
                    }
                }
            },

            styleFun: {
                get: function () {
                    return this._styleFun;
                },
                set: function (value) {
                    if (this._styleFun !== value) {
                        this._styleFun = value;
                        this.reload();
                    }
                }
            },

            errorEvent : {
                get : function() {
                    return this._errorEvent;
                }
            },
        });


        function findTileInQueue(x, y, level, tileQueue) {
            var item = tileQueue.head;
            while (item != undefined && !(item.xMvt == x && item.yMvt == y && item.zMvt == level)) {
                item = item.replacementNext;
            }
            return item;
        };

        function remove(tileReplacementQueue, item) {
            var previous = item.replacementPrevious;
            var next = item.replacementNext;

            if (item === tileReplacementQueue._lastBeforeStartOfFrame) {
                tileReplacementQueue._lastBeforeStartOfFrame = next;
            }

            if (item === tileReplacementQueue.head) {
                tileReplacementQueue.head = next;
            } else {
                previous.replacementNext = next;
            }

            if (item === tileReplacementQueue.tail) {
                tileReplacementQueue.tail = previous;
            } else {
                next.replacementPrevious = previous;
            }

            item.replacementPrevious = undefined;
            item.replacementNext = undefined;

            --tileReplacementQueue.count;
        }

        function trimTiles(tileQueue, maximumTiles) {
            var tileToTrim = tileQueue.tail;
            while (tileQueue.count > maximumTiles &&
            defined(tileToTrim)) {
                var previous = tileToTrim.replacementPrevious;
                remove(tileQueue, tileToTrim);
                delete tileToTrim;
                tileToTrim = null;
                tileToTrim = previous;
            }
        };

        MVTProvider.prototype.getTileCredits = function (x, y, level) {
            return undefined;
        };

        MVTProvider.prototype.trimTile = function () {
            if (this._tileQueue.count > this._cacheSize) {
                trimTiles(this._tileQueue, this._cacheSize / 2);
            }
        }

        MVTProvider.prototype.markTileRendered = function (canvas) {
            this._tileQueue.markTileRendered(canvas);
        }

        MVTProvider.prototype.beginFrame = function (frameState) {
            if (!!this.owner) {
                this.owner.beginFrame(frameState, this);
            }
        }

        MVTProvider.prototype.endFrame = function (frameState) {
            if (!!this.owner) {
                this.owner.endFrame(frameState, this);
            }
        }

        MVTProvider.prototype.requestImage = function (x, y, level, request, frameState) {
            var cacheTile = findTileInQueue(x, y, level, this._tileQueue);
            if (cacheTile != undefined) {
                return cacheTile;
            } else {
                return this.owner.requestTile(x, y, level, request, frameState, this);
            }
        };

        MVTProvider.prototype.pickFeatures = function (x, y, level, longitude, latitude) {
            return undefined;
        };

        MVTProvider.prototype.reload = function () {
            if (defined(this._reload)) {
                this._tileQueue = new TileReplacementQueue();
                this._reload();
            }
        }

        MVTProvider.prototype.setStyleFun = function (value) {
            this._styleFun = value;
            this.reload();
        }

        return MVTProvider;
    });
